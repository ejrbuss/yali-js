(def *root-env* (__env))

;; temporary and bad
(def reload (proc ()
	(eval (js.fs.readFileSync "./src/prelude.yali" "utf-8") *root-env*)))

(def log (proc (... args)
	(def write process.stdout.write)
	(for-each (proc (a)
			(write a)
			(write " "))
		args)
	(write "\n")
	nil))

;; Bootstrap basic list operations

(def-impl (first List) (proc (list)
	(list.first)))

(def-impl (rest List) (proc (list)
	(list.rest)))

(def-impl (empty? List) (proc (list)
	(list.isEmpty)))

;; Basic macros

;; TODO fallthrough should result in error, not nil!
(def-macro (def-macros ... defs)
	(def-proc (def-to-case def)
		;; todo assert names match
		(let (
			[sig body] def
			binding [`List ... (rest sig)])
			`(,binding ,body)))
	(let (
		name (first (first defs))
		cases (flatten (map def-to-case (chunk 2 defs))))
		`(def-macro (,name ... args) (match args ,,, cases))))

;; TODO fallthrouuugh should result in error, not nil!
(def-macro (def-procs ... defs)
	(def-proc (def-to-case def)
		;; todo assert names match
		(let (
			[sig body] def
			binding [`List ... (rest sig)])
			`(,binding ,body)))
	(let (
		name (first (first defs))
		cases (flatten (map def-to-case (chunk 2 defs))))
		`(def-proc (,name ... args) (match args ,,, cases))))

(def-macros
	(and) true
	(and a) a
	(and a b) (if a b a)
	(and a ... rest) (if a (and ... rest) a))

(def-macros
	(or) false
	(or a) a
	(or a b) (if a a b)
	(or a ... rest) (if a a (or ... rest)))

(def-macros
	(cond) nil
	(cond condition body) `(if ,condition ,body)
	(cond condition body ... more) `(if ,condition ,body ,((id cond) ... more)))

;; basic functions

(def-proc (id a) a)

(def-proc (not a)
	(if a false true))

(def-procs
	(compose f) f
	(compose f g) (proc (... args) (f (g ... args)))
	(compose f ... gs) (proc (... args) (f ((. ... gs) ... args))))

(def-proc (Nil? a) (binary= nil a))
(def-proc (Bool? a) (binary= "boolean" (js.typeof a)))
(def-proc (Str? a) (binary= "string" (js.typeof a)))
(def-proc (Sym? a) (binary= "symbol" (js.typeof a)))
(def-proc (Keyword? a) (binary= Keyword (type-of a)))
(def-proc (List? a) (binary= List (type-of a)))
(def-proc (Map? a) (binary= Map (type-of a)))
(def-proc (Proc? a) (binary= "function" (js.typeof)))
(def-proc (Interface? a) (binary= Interface (type-of a)))

;; proc methods

(def-impl (to-Proc Interface) (proc (i)
	i.dispatch))

;; nil methods

(def-impl (to-Bool Nil) (proc () false))
(def-impl (to-Str Nil) (proc () ""))

;; numeric operators

(def-interface (inc a))
(def-interface (dec a))

(def-impl (inc Num) (proc (a) (js.++ a)))
(def-impl (dec Num) (proc (a) (js.-- a)))

(def-interface (unary+ a))
(def-interface (binary+ a b))

(def-impl (unary+ Num) id)
(def-impl (binary+ Num Num) js.+)

(def-procs
	(+) 0
	(+ a) (unary+ a)
	(+ a b) (binary+ a b)
	(+ a ... rest) (reduce binary+ a rest))

(def-interface (unary- a))
(def-interface (binary- a b))

(def-impl (unary- Num) js.u-)
(def-impl (binary- Num Num) js.-)

(def-procs
	(-) 0
	(- a) (unary- a)
	(- a b) (binary- a b)
	(- a ... rest) (reduce binary- a rest))

(def-interface (unary* a))
(def-interface (binary* a b))

(def-impl (unary* Num) id)
(def-impl (binary* Num Num) js.*)

(def-procs
	(*) 1
	(* a) (unary* a)
	(* a b) (binary* a b)
	(* a ... rest) (reduce binary* a rest))

(def-interface (unary/ a))
(def-interface (binary/ a b))

(def-impl (unary/ Num) id)
(def-impl (binary/ Num Num) js./)

(def-procs
	(/) 1
	(/ a) (unary/ a)
	(/ a b) (binary/ a b)
	(/ a ... rest) (reduce binary/ a rest))

(def-interface (pow a b))

(def-impl (pow Num Num) js.Math.pow)

(def-interface (mod a b))

(def-impl (mod Num Num) js.%)

(def-interface (floor a))
(def-interface (ceil a))
(def-interface (round a))

(def-impl (floor Num) js.Math.floor)
(def-impl (ceil Num) js.Math.ceil)
(def-impl (round Num) js.Math.round)

(def-interface (rand a) {
	:default-impl (proc (... args)
	;; fallback is expected for most calls
	(if (empty? args)
		(js.Math.random)
		;; todo better error handling here
		((rand.get-method [(first args)]) ... args))) })

(def-impl (rand Num) (proc (... args)
	(match args
		[] (js.Math.random)
		[max] (floor (* (js.Math.random) max))
		[min max] (floor (+ min (* (js.Math.random) (- max min)))))))

(def-impl (rand List)	(proc (list)
	(nth list (rand (count list)))))

;; ((get Math floor))
;; (set! Math floor "")
;; (def Point (type (self x y)
;;		(def-prop self.x x) ; assign and create proc self.x
;;      (def-prop self.y y)))
;;
;; as special forms::
;; def def-macro def-type def-prop

;; (def-struct (Point x { :type NUm } y { :type NUm }))
;; ordering



;; iterator methods

(def-interface (nth a)) ;; todo fallback

(def-impl (nth List) (proc (a ... args)
	(a.get ... args)))

;; structural

;; import/export

;; (export def x 4)
;; (import "my-module.yali" {}) ;
;; (import-as vec "my-vec-module.yali" {}) ; file extension excluded
;; (module "name" {} ...) ; name will be appended to the file module it is present in, but can be overriden
;; support yali and js files

;; (def (first list::(List Any))
;;   (list.first))

;; (List Any)

(def-struct (Ratio num denom))
;; syntactic sugarg for
(def-struct (Ratio num: T denom: T) (forall T))