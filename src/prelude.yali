(def *root-env* (__env))

;; temporary and bad
(def-proc (reload)
	(let (
		prelude-file "./src/prelude.yali"
		source (js.fs.readFileSync prelude-file "utf-8")
		forms (read source prelude-file))
		(reduce (proc (acc form) (eval form *root-env*)) nil forms)))

(def-proc (log ... args)
	(def write js.process.stdout.write)
	(for-each (proc (a)
			(write (Str a))
			(write " "))
		args)
	(write "\n")
	nil)

;; Bootstrap basic list operations

(def-impl (first List) (proc (list)
	(list.first)))

(def-impl (rest List) (proc (list)
	(list.rest)))

(def-impl (empty? List) (proc (list)
	(list.isEmpty)))

(def-proc (second xs)
	(first (first xs)))

;; Bootstrap asserts

(def-macro (assert condition message)
	`(if ,condition
		nil
		(throw (error (or
			,message
			(Str "Assertion of `" (print (quote ,condition)) "` failed!"))))))

;; Basic macros

(def-macro (def-macros ... definitions)
	(def-proc (match-case expected-name sig body)
			(assert (binary= expected-name (first sig)))
			`([,(rest sig)] ,body))
	(if (empty? definitions)
		(throw (error "No matched cases for multi macro!"))
		(let (
			name (second definitions)
			sig-body-pairs (chunk 2 definitions)
			match-cases (map (proc (pair) (match-case name (first pair) (second pair))) sig-body-pairs))
			`(def-macro (,name ... args) (match args ,,, match-cases)))))

(def-macro (def-procs ... definitions)
	(def-proc (match-case expected-name sig body)
			(assert (binary= expected-name (first sig)))
			`([,(rest sig)] ,body))
	(if (empty? definitions)
		(throw (error "No matched cases for multi macro!"))
		(let (
			name (second definitions)
			sig-body-pairs (chunk 2 definitions)
			match-cases (map (proc (pair) (match-case name (first pair) (second pair))) sig-body-pairs))
			`(def-proc (,name ... args) (match args ,,, match-cases)))))

(def-macros
	(and) true
	(and a) a
	(and a b) (if a b a)
	(and a ... rest) (if a (and ... rest) a))

(def-macros
	(or) false
	(or a) a
	(or a b) (if a a b)
	(or a ... rest) (if a a (or ... rest)))

(def-macros
	(cond) nil
	(cond condition body) `(if ,condition ,body)
	(cond condition body ... more) `(if ,condition ,body ,((id cond) ... more)))

;; basic functions

(def-proc (id a) a)

(def-proc (not a)
	(if a false true))

(def-procs
	(compose f) f
	(compose f g) (proc (... args) (f (g ... args)))
	(compose f ... gs) (proc (... args) (f ((. ... gs) ... args))))

(def-proc (Nil? a) (binary= nil a))
(def-proc (Bool? a) (binary= "boolean" (js.typeof a)))
(def-proc (Str? a) (binary= "string" (js.typeof a)))
(def-proc (Sym? a) (binary= "symbol" (js.typeof a)))
(def-proc (Keyword? a) (binary= Keyword (type-of a)))
(def-proc (List? a) (binary= List (type-of a)))
(def-proc (Map? a) (binary= Map (type-of a)))
(def-proc (Proc? a) (binary= "function" (js.typeof)))
(def-proc (Interface? a) (binary= Interface (type-of a)))

;; proc methods

(def-impl (to-Proc Interface) (proc (i)
	i.dispatch))

;; nil methods

(def-impl (to-Bool Nil) (proc () false))
(def-impl (to-Str Nil) (proc () ""))

;; numeric operators

(def-interface (inc a))
(def-interface (dec a))

(def-impl (inc Num) (proc (a) (js.++ a)))
(def-impl (dec Num) (proc (a) (js.-- a)))

(def-interface (unary+ a))
(def-interface (binary+ a b))

(def-impl (unary+ Num) id)
(def-impl (binary+ Num Num) js.+)

(def-procs
	(+) 0
	(+ a) (unary+ a)
	(+ a b) (binary+ a b)
	(+ a ... rest) (reduce binary+ a rest))

(def-interface (unary- a))
(def-interface (binary- a b))

(def-impl (unary- Num) js.u-)
(def-impl (binary- Num Num) js.-)

(def-procs
	(-) 0
	(- a) (unary- a)
	(- a b) (binary- a b)
	(- a ... rest) (reduce binary- a rest))

(def-interface (unary* a))
(def-interface (binary* a b))

(def-impl (unary* Num) id)
(def-impl (binary* Num Num) js.*)

(def-procs
	(*) 1
	(* a) (unary* a)
	(* a b) (binary* a b)
	(* a ... rest) (reduce binary* a rest))

(def-interface (unary/ a))
(def-interface (binary/ a b))

(def-impl (unary/ Num) id)
(def-impl (binary/ Num Num) js./)

(def-procs
	(/) 1
	(/ a) (unary/ a)
	(/ a b) (binary/ a b)
	(/ a ... rest) (reduce binary/ a rest))

(def-interface (pow a b))

(def-impl (pow Num Num) js.Math.pow)

(def-interface (mod a b))

(def-impl (mod Num Num) js.%)

(def-interface (floor a))
(def-interface (ceil a))
(def-interface (round a))

(def-impl (floor Num) js.Math.floor)
(def-impl (ceil Num) js.Math.ceil)
(def-impl (round Num) js.Math.round)

(def-interface (unary-rand a))

(def-impl (unary-rand Num) (proc (max)
	(floor (* js.Math.random max))))

(def-impl (unary-rand List) (proc (list)
	(nth list (rand (count list)))))

(def-interface (binary-rand a b))

(def-impl (binary-rand Num Num) (proc (min max)
	(floor (+ min (* js.Math.random (- max min))))))

(def-procs
	(rand) (js.Math.random)
	(rand a) (unary-rand a)
	(rand a b) (binary-rand a b))

;; iterator methods

(def-interface (nth a) {
	:default-impl (proc (xs n)
		(if (= n 0)
			(first xs)
			(nth (rest xs) (dec n))))
})

(def-impl (nth List) (proc (a ... args)
	(a.get ... args)))

;; structural

;; import/export

;; (export def x 4)
;; (import "my-module.yali" {}) ;
;; (import-as vec "my-vec-module.yali" {}) ; file extension excluded
;; (module "name" {} ...) ; name will be appended to the file module it is present in, but can be overriden
;; support yali and js files

;; smoke test

(assert true)
(assert (not false))
